<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
   <meta http-equiv="content-type" content="text/html;charset=UTF-8">
   <style type="text/css">
   /*CSS stylesheet is based on killwing's flavored markdown style:https://gist.github.com/2937864*/body{    margin: 0 auto;    font: 13px/1.231 Helvetica, Arial, sans-serif;    color: #444444;    line-height: 1;    max-width: 960px;    padding: 5px;}h1, h2, h3, h4 {    color: #111111;    font-weight: 400;}h1, h2, h3, h4, h5, p {    margin-bottom: 16px;    padding: 0;}h1 {    font-size: 28px;}h2 {    font-size: 22px;    margin: 20px 0 6px;}h3 {    font-size: 21px;}h4 {    font-size: 18px;}h5 {    font-size: 16px;}a {    color: #0099ff;    margin: 0;    padding: 0;    vertical-align: baseline;}a:link,a:visited{ text-decoration:none;}a:hover{ text-decoration:underline;}ul, ol {    padding: 0;    margin: 0;}li {    line-height: 24px;    margin-left: 44px;}li ul, li ul {    margin-left: 24px;}ul, ol {    font-size: 14px;    line-height: 20px;    max-width: 540px;}p {    font-size: 14px;    line-height: 20px;    max-width: 540px;    margin-top: 3px;}pre {    padding: 0px 4px;    max-width: 800px;    white-space: pre-wrap;    font-family: Consolas, Monaco, Andale Mono, monospace;    line-height: 1.5;    font-size: 13px;    border: 1px solid #ddd;    background-color: #f7f7f7;    border-radius: 3px;}code {    font-family: Consolas, Monaco, Andale Mono, monospace;    line-height: 1.5;    font-size: 13px;    border: 1px solid #ddd;    background-color: #f7f7f7;    border-radius: 3px;}pre code {    border: 0px;}aside {    display: block;    float: right;    width: 390px;}blockquote {    border-left:.5em solid #40AA53;    padding: 0 2em;    margin-left:0;    max-width: 476px;}blockquote  cite {    font-size:14px;    line-height:20px;    color:#bfbfbf;}blockquote cite:before {    content: '\2014 \00A0';}blockquote p {      color: #666;    max-width: 460px;}hr {    height: 1px;    border: none;    border-top: 1px dashed #0066CC}button,input,select,textarea {  font-size: 100%;  margin: 0;  vertical-align: baseline;  *vertical-align: middle;}button, input {  line-height: normal;  *overflow: visible;}button::-moz-focus-inner, input::-moz-focus-inner {  border: 0;  padding: 0;}button,input[type="button"],input[type="reset"],input[type="submit"] {  cursor: pointer;  -webkit-appearance: button;}input[type=checkbox], input[type=radio] {  cursor: pointer;}/* override default chrome & firefox settings */input:not([type="image"]), textarea {  -webkit-box-sizing: content-box;  -moz-box-sizing: content-box;  box-sizing: content-box;}input[type="search"] {  -webkit-appearance: textfield;  -webkit-box-sizing: content-box;  -moz-box-sizing: content-box;  box-sizing: content-box;}input[type="search"]::-webkit-search-decoration {  -webkit-appearance: none;}label,input,select,textarea {  font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;  font-size: 13px;  font-weight: normal;  line-height: normal;  margin-bottom: 18px;}input[type=checkbox], input[type=radio] {  cursor: pointer;  margin-bottom: 0;}input[type=text],input[type=password],textarea,select {  display: inline-block;  width: 210px;  padding: 4px;  font-size: 13px;  font-weight: normal;  line-height: 18px;  height: 18px;  color: #808080;  border: 1px solid #ccc;  -webkit-border-radius: 3px;  -moz-border-radius: 3px;  border-radius: 3px;}select, input[type=file] {  height: 27px;  line-height: 27px;}textarea {  height: auto;}/* grey out placeholders */:-moz-placeholder {  color: #bfbfbf;}::-webkit-input-placeholder {  color: #bfbfbf;}input[type=text],input[type=password],select,textarea {  -webkit-transition: border linear 0.2s, box-shadow linear 0.2s;  -moz-transition: border linear 0.2s, box-shadow linear 0.2s;  transition: border linear 0.2s, box-shadow linear 0.2s;  -webkit-box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);  -moz-box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);  box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);}input[type=text]:focus, input[type=password]:focus, textarea:focus {  outline: none;  border-color: rgba(82, 168, 236, 0.8);  -webkit-box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1), 0 0 8px rgba(82, 168, 236, 0.6);  -moz-box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1), 0 0 8px rgba(82, 168, 236, 0.6);  box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1), 0 0 8px rgba(82, 168, 236, 0.6);}/* buttons */button {  display: inline-block;  padding: 4px 14px;  font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;  font-size: 13px;  line-height: 18px;  -webkit-border-radius: 4px;  -moz-border-radius: 4px;  border-radius: 4px;  -webkit-box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.2), 0 1px 2px rgba(0, 0, 0, 0.05);  -moz-box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.2), 0 1px 2px rgba(0, 0, 0, 0.05);  box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.2), 0 1px 2px rgba(0, 0, 0, 0.05);  background-color: #0064cd;  background-repeat: repeat-x;  background-image: -khtml-gradient(linear, left top, left bottom, from(#049cdb), to(#0064cd));  background-image: -moz-linear-gradient(top, #049cdb, #0064cd);  background-image: -ms-linear-gradient(top, #049cdb, #0064cd);  background-image: -webkit-gradient(linear, left top, left bottom, color-stop(0%, #049cdb), color-stop(100%, #0064cd));  background-image: -webkit-linear-gradient(top, #049cdb, #0064cd);  background-image: -o-linear-gradient(top, #049cdb, #0064cd);  background-image: linear-gradient(top, #049cdb, #0064cd);  color: #fff;  text-shadow: 0 -1px 0 rgba(0, 0, 0, 0.25);  border: 1px solid #004b9a;  border-bottom-color: #003f81;  -webkit-transition: 0.1s linear all;  -moz-transition: 0.1s linear all;  transition: 0.1s linear all;  border-color: #0064cd #0064cd #003f81;  border-color: rgba(0, 0, 0, 0.1) rgba(0, 0, 0, 0.1) rgba(0, 0, 0, 0.25);}button:hover {  color: #fff;  background-position: 0 -15px;  text-decoration: none;}button:active {  -webkit-box-shadow: inset 0 3px 7px rgba(0, 0, 0, 0.15), 0 1px 2px rgba(0, 0, 0, 0.05);  -moz-box-shadow: inset 0 3px 7px rgba(0, 0, 0, 0.15), 0 1px 2px rgba(0, 0, 0, 0.05);  box-shadow: inset 0 3px 7px rgba(0, 0, 0, 0.15), 0 1px 2px rgba(0, 0, 0, 0.05);}button::-moz-focus-inner {  padding: 0;  border: 0;}/* table  */table {    border-spacing: 0;    border: 1px solid #ccc;}td, th{    border: 1px solid #ccc;    padding: 5px;}/* code syntax highlight.Documentation: http://www.mdcharm.com/documentation/code_syntax_highlighting.html#custom_your_own */pre .literal,pre .comment,pre .template_comment,pre .diff .header,pre .javadoc {    color: #008000;}pre .keyword,pre .css .rule .keyword,pre .winutils,pre .javascript .title,pre .nginx .title,pre .subst,pre .request,pre .status {    color: #0000FF;    font-weight: bold}pre .number,pre .hexcolor,pre .python .decorator,pre .ruby .constant {    color: #0000FF;}pre .string,pre .tag .value,pre .phpdoc,pre .tex .formula {    color: #D14}pre .title,pre .id {    color: #900;    font-weight: bold}pre .javascript .title,pre .lisp .title,pre .clojure .title,pre .subst {    font-weight: normal}pre .class .title,pre .haskell .type,pre .vhdl .literal,pre .tex .command {    color: #458;    font-weight: bold}pre .tag,pre .tag .title,pre .rules .property,pre .django .tag .keyword {    color: #000080;    font-weight: normal}pre .attribute,pre .variable,pre .lisp .body {    color: #008080}pre .regexp {    color: #009926}pre .class {    color: #458;    font-weight: bold}pre .symbol,pre .ruby .symbol .string,pre .lisp .keyword,pre .tex .special,pre .prompt {    color: #990073}pre .built_in,pre .lisp .title,pre .clojure .built_in {    color: #0086b3}pre .preprocessor,pre .pi,pre .doctype,pre .shebang,pre .cdata {    color: #999;    font-weight: bold}pre .deletion {    background: #fdd}pre .addition {    background: #dfd}pre .diff .change {    background: #0086b3}pre .chunk {    color: #aaa}pre .markdown .header {    color: #800;    font-weight: bold;}pre .markdown .blockquote {    color: #888;}pre .markdown .link_label {    color: #88F;}pre .markdown .strong {    font-weight: bold;}pre .markdown .emphasis {    font-style: italic;}
   </style>
   
   
</head>
<body>
    <h1>C++标准程序库读书笔记</h1>

<h2>STL算法</h2>

<p>包含头文件 &lt;algorithm&gt;或&lt;numeric&gt;</p>

<p>STL算法采用覆盖模式而非安插模式，所以调用者必须保证目标区间拥有足够的元素空间。也可以运用特殊的安插型迭代器将覆盖模式改变为安插模式。</p>

<p><strong>可以运用条件判断式完成以下工作：</strong></p>

<ul>
<li>对于搜寻算法，可以传递一个函数或者仿函数，指定一个一元判断式作为搜寻准则。</li>
<li>对于排序算法，可以传递一个函数或者仿函数，指定一个二元判断式作为排序准则。</li>
<li>可以传递一个一元判断式作为准则，判断是否应该对某些元素施以某项运算。</li>
<li>可以为某个数值算法指定一个数值运算。</li>
</ul>

<p><strong><em>判断式不应该在函数调用过程中改变其自身状态</em></strong></p>

<p>STL算法命名时，引入两个特别的尾词：</p>

<ol>
<li>尾词 _if</li>
<li>尾词 _copy</li>
</ol>

<p><strong>STL算法分类：</strong></p>

<ul>
<li>非变动性算法 <strong>nonmodifying algorithm</strong></li>
<li>变动性算法 <strong>modifying algorithm</strong></li>
<li>移除性算法 <strong>removing algorithm</strong></li>
<li>变序性算法 <strong>mutating algorithm</strong></li>
<li>排序算法 <strong>sorting algorithm</strong></li>
<li>已序区间算法 <strong>sorted range algorithm</strong></li>
<li>数值算法 <strong>numeric algorithm</strong></li>
</ul>

<h3>非变动性算法</h3>

<p>通过input和forward迭代器完成工作，因此可以作用于所有标准容器身上。</p>

<table><thead>
<tr>
<th align="left">名称</th>
<th align="right">作用</th>
</tr>
</thead><tbody>
<tr>
<td align="left">for_each()</td>
<td align="right">对每个元素执行某操作</td>
</tr>
<tr>
<td align="left">count()</td>
<td align="right">返回元素个数</td>
</tr>
<tr>
<td align="left">count_if()</td>
<td align="right">返回满足某一个准则的元素个数</td>
</tr>
<tr>
<td align="left">min_element()</td>
<td align="right">返回最小值元素（以一个迭代器表示）</td>
</tr>
<tr>
<td align="left">max_element()</td>
<td align="right">返回最大值元素</td>
</tr>
<tr>
<td align="left">find()</td>
<td align="right">搜寻等于某值的第一个元素</td>
</tr>
<tr>
<td align="left">find_if()</td>
<td align="right">搜寻满足某个准则的第一个元素</td>
</tr>
<tr>
<td align="left">search_n()</td>
<td align="right">搜寻具有某些特性的第一段n个连续元素</td>
</tr>
<tr>
<td align="left">search()</td>
<td align="right">搜寻某个子区间第一次出现位置</td>
</tr>
<tr>
<td align="left">find_end()</td>
<td align="right">搜寻某个子区间最后一次出现位置</td>
</tr>
<tr>
<td align="left">find_first_of()</td>
<td align="right">搜寻等于某数个值之一的第一个元素</td>
</tr>
<tr>
<td align="left">adjancent_find()</td>
<td align="right">搜寻连续两个相等的（或者符合特等准则）的元素</td>
</tr>
<tr>
<td align="left">equal()</td>
<td align="right">判断两区间是否相等</td>
</tr>
<tr>
<td align="left">mismatch()</td>
<td align="right">返回两个序列的各组对应元素中，第一对不相等元素</td>
</tr>
<tr>
<td align="left">lexicographical_compare()</td>
<td align="right">判断某一序列在字典顺序下是否小于另一序列</td>
</tr>
</tbody></table>

<hr>

<p><strong>与string 搜寻函数的比较</strong></p>

<p>|搜寻|string函数|STL算法|
|:--|----------|----：|
|某元素第一次出现位置|find()|find()|
|某元素最后一次出现位置|rfind()|find()，采用逆向迭代器|
|某子区间第一次出现位置|find()|search()|
|某子区间最后一次出现位置|rfind()|find_end()|
|某数个元素第一次出现位置|find_first_of()|find_first_of()|
|某数个元素最后一次出现位置|find_last_of()|find_first_of()采用逆向迭代器|</p>

<h2>|n个连续元素第一次出现位置||search_n()|</h2>

<h3>变动性算法</h3>

<table><thead>
<tr>
<th align="left">名称</th>
<th align="right">效果</th>
</tr>
</thead><tbody>
<tr>
<td align="left">foreach()</td>
<td align="right">针对某个元素执行某项操作</td>
</tr>
<tr>
<td align="left">copy()</td>
<td align="right">从第一个元素开始，复制某段区间</td>
</tr>
<tr>
<td align="left">copy_backward()</td>
<td align="right">从最后一个元素开始，复制某段区间</td>
</tr>
<tr>
<td align="left">transform()</td>
<td align="right">变动元素，将两个区间的元素合并</td>
</tr>
<tr>
<td align="left">merge()</td>
<td align="right">合并两个区间</td>
</tr>
<tr>
<td align="left">swap_range()</td>
<td align="right">交换两区间内的元素</td>
</tr>
<tr>
<td align="left">fill()</td>
<td align="right">以给定值替换每一个元素</td>
</tr>
<tr>
<td align="left">fill_n()</td>
<td align="right">以给定值替换n个元素</td>
</tr>
<tr>
<td align="left">generate()</td>
<td align="right">以某项操作的结果替换每一个结果</td>
</tr>
<tr>
<td align="left">generate_n()</td>
<td align="right">以某项操作的结果替换n个元素</td>
</tr>
<tr>
<td align="left">replace()</td>
<td align="right">将具有某项特定值的元素替换为另一个值</td>
</tr>
<tr>
<td align="left">replace_if()</td>
<td align="right">将符合某准则的元素替换为另一个值</td>
</tr>
<tr>
<td align="left">replace_copy()</td>
<td align="right">复制整个区间，同时并将具有某特定值的元素替换为另一个值</td>
</tr>
<tr>
<td align="left">replace_copy_if()</td>
<td align="right">复制整个区间，同时并将符合某准则的元素替换为另一个值</td>
</tr>
</tbody></table>

<hr>

<h3>移除性算法</h3>

<p>可以移除某区间内的元素，也可以在复制过程中执行移除动作。</p>

<table><thead>
<tr>
<th align="left">名称</th>
<th align="right">效果</th>
</tr>
</thead><tbody>
<tr>
<td align="left">remove()</td>
<td align="right">将等于某特定值的元素全部移除</td>
</tr>
<tr>
<td align="left">remove_if()</td>
<td align="right">将满足某准则的元素全部移除</td>
</tr>
<tr>
<td align="left">remove_copy()</td>
<td align="right">将不等于某特定值的元素全部复制到它处</td>
</tr>
<tr>
<td align="left">remove_copy_if()</td>
<td align="right">将不满足某准则的元素全部复制到它处</td>
</tr>
<tr>
<td align="left">unique()</td>
<td align="right">移除毗邻的重复元素</td>
</tr>
<tr>
<td align="left">unique_copy()</td>
<td align="right">移除毗邻的重复元素，并复制到它处</td>
</tr>
</tbody></table>

<h2>移除算法只是在逻辑上移除元素，手段是:将不需被移除的元素往前覆盖应被移除的元素，因此它并不改变操作区间内的元素个数，而是返回逻辑上的新终点位置。</h2>

<h3>变序性算法</h3>

<p>通过元素值得赋值和交换，改变元素顺序但不改变元素值。</p>

<table><thead>
<tr>
<th align="left">名称</th>
<th align="right">效果</th>
</tr>
</thead><tbody>
<tr>
<td align="left">reverse()</td>
<td align="right">将元素的次序逆转</td>
</tr>
<tr>
<td align="left">reverse_copy()</td>
<td align="right">复制的同时，逆转元素顺序</td>
</tr>
<tr>
<td align="left">rotate()</td>
<td align="right">旋转元素次序</td>
</tr>
<tr>
<td align="left">rotate_copy()</td>
<td align="right">复制的同时，旋转元素次序</td>
</tr>
<tr>
<td align="left">next_permutation()</td>
<td align="right">得到元素的下一个排列次序</td>
</tr>
<tr>
<td align="left">prev_permutation()</td>
<td align="right">得到元素的上一个排列次序</td>
</tr>
<tr>
<td align="left">random_shuffle()</td>
<td align="right">将元素的次序随机打乱</td>
</tr>
<tr>
<td align="left">partition()</td>
<td align="right">改变元素次序，将符合某准则者移到前面</td>
</tr>
<tr>
<td align="left">stable_partiton()</td>
<td align="right">与partition() 相似，但保持符准则与不符合准则之各个元素之间的相对位置</td>
</tr>
</tbody></table>

<hr>

<h3>排序算法</h3>

<p>排序算法的复杂度通常低于线性算法，而且需要动用随机存取迭代器。</p>

<table><thead>
<tr>
<th align="left">名称</th>
<th align="right">效果</th>
</tr>
</thead><tbody>
<tr>
<td align="left">sort()</td>
<td align="right">对所有元素排序</td>
</tr>
<tr>
<td align="left">stable_sort()</td>
<td align="right">对所有元素排序，并保持相等元素间的相等次序</td>
</tr>
<tr>
<td align="left">partial_sort()</td>
<td align="right">排序，直到前n个元素就位</td>
</tr>
<tr>
<td align="left">partial_sort_copy()</td>
<td align="right">排序，直到前n个元素就位，结果复制于它处</td>
</tr>
<tr>
<td align="left">nth_element()</td>
<td align="right">根据第n个位置进行排序</td>
</tr>
<tr>
<td align="left">partition()</td>
<td align="right">改变元素次序，使符合某准则的元素放在前面</td>
</tr>
<tr>
<td align="left">stable_partiton()</td>
<td align="right">与partiton()相同，但保持符合准则和不符合准则的各个元素之间的相对位置</td>
</tr>
<tr>
<td align="left">make_heap()</td>
<td align="right">将一个区间转换为一个heap</td>
</tr>
<tr>
<td align="left">push_heap()</td>
<td align="right">将元素加入一个heap</td>
</tr>
<tr>
<td align="left">pop_heap()</td>
<td align="right">从heap移除一个元素</td>
</tr>
<tr>
<td align="left">sort_heap()</td>
<td align="right">对heap进行排序（执行后就不再是个heap了）</td>
</tr>
</tbody></table>

<ul>
<li>sort()内部采用quicksort算法</li>
<li>partial_sort()内部采用heapsort算法</li>
<li>stable_sort()内部采用mergesort()</li>
</ul>

<hr>

<h3>已序区间算法</h3>

<table><thead>
<tr>
<th align="left">名字</th>
<th align="right">效果</th>
</tr>
</thead><tbody>
<tr>
<td align="left">binary_search()</td>
<td align="right">判断某区间内是否包含某个元素</td>
</tr>
<tr>
<td align="left">includes()</td>
<td align="right">判断某区间内的每一个元素是否都涵盖于另一个区间中</td>
</tr>
<tr>
<td align="left">lower_bound()</td>
<td align="right">搜寻第一个大于等于给定值的元素</td>
</tr>
<tr>
<td align="left">upper_bound()</td>
<td align="right">搜寻第一个大于给定值的元素</td>
</tr>
<tr>
<td align="left">equal_range()</td>
<td align="right">返回等于给定值的所有元素构成的区间</td>
</tr>
<tr>
<td align="left">merge()</td>
<td align="right">将两个区间的元素合并</td>
</tr>
<tr>
<td align="left">set_union()</td>
<td align="right">求两个区间的并集</td>
</tr>
<tr>
<td align="left">set_intersection()</td>
<td align="right">求两个区间的交集</td>
</tr>
<tr>
<td align="left">set_difference()</td>
<td align="right">求位于第一区间但不位于第二区间的所有元素，形成一个已序区间</td>
</tr>
<tr>
<td align="left">set_symmetric_difference()</td>
<td align="right">找出只出现于两区间之一的所有元素，形成一个已序区间</td>
</tr>
<tr>
<td align="left">inplace_merge()</td>
<td align="right">将两个连续的已序区间合并</td>
</tr>
</tbody></table>

<hr>

<h3>数值算法</h3>

<table><thead>
<tr>
<th align="left">名字</th>
<th align="right">效果</th>
</tr>
</thead><tbody>
<tr>
<td align="left">accumulate()</td>
<td align="right">组合所有元素（求总和，求乘积）</td>
</tr>
<tr>
<td align="left">inner_product()</td>
<td align="right">组合两区间内的所有元素</td>
</tr>
<tr>
<td align="left">adjacent_difference()</td>
<td align="right">将每个元素和其前一元素组合</td>
</tr>
<tr>
<td align="left"></td>
<td align="right">partial_sum()</td>
</tr>
</tbody></table>

<hr>

</body>
</html>